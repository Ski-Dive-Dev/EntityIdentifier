# EntityIdentifier
A project to abstract entity ID's so that their underlying type (e.g., string, int, GUID) can be changed at any time with minimal code changes.

Any entity's ID is normally an immutable value object, whose type varies depending on its purpose or more often, its underlying persistent storage.

ID's are most often string, integer or GUID/UUID values.  They can either be generated by the persistent store itself (a [surrogate key](https://en.wikipedia.org/wiki/Surrogate_key)), or they can be a [natural key](https://en.wikipedia.org/wiki/Natural_key).

### A Project's Change of Scope
Sometimes a natural key is used in a project without having full knowledge of the type it should be.  For example, in the United States, postal codes are identifiers having five numeric digits.  The U.S. programmer uses an integer type for its storage.

The project begins to get international use, and so now the integer type cannot support Canadian postal codes.  Add a new column?  Technical debt.

### A Project Changing Databases
During a project's refactor, it may be desired to update the code to make it more friendly to NoSQL databases, in which keys may not be numeric.  Or, it may be desired to update the code to make it more friendly to a distributed architecture, which would prefer GUIDs as unique identifiers.

However, during the refactor, the existing relational database is used and it requires integer keys.

### EntityIdentifier
Using `EntityIdentifier` as the type for an entity's ID abstracts the underlying type from code, allowing code to be written against the ID without it breaking should that underlying type change in the future.

## Implementing EntityIdentifier
Assume there is a `Person` class which has an `ID` property.
``` C#
    public class Person
    {
        public int ID { get; set; }

        public string GivenName { get; set; }
        public string Surname { get; set; }
    }
```

To support an abstracted ID with `EntityIdentifier`, the `ID` property's type would be changed to `IIdentifier`, from the namespace `SkiDiveDev.EntityIdentifier`.
``` C#
    public class Person
    {
        public IIdentifier ID { get; set; }

        public string GivenName { get; set; }
        public string Surname { get; set; }
    }
```
The following class is "boilerplate" code -- for ID's with an underlying `int` type, it can be used as-is by just changing the name of the class itself from `PersonID` to whatever is appropriate for the entity it will be used with:
``` C#
    /// <summary>
    /// A Class which represents a <see cref="Person"/> entity's ID as an <see langref="int"/>.
    /// </summary>
    class PersonID : IntIdentifier
    {
        public PersonID() : base()
        { /* No additional construction required. */ }

        public PersonID(int id) : base(id)
        { /* No additional construction required. */ }

        public PersonID(IntIdentifier id) : base(id.ID)
        { /* No additional construction required. */ }

        public PersonID(string value) : base(Parse(value).ID)
        { /* No additional construction required. */ }


        public static bool TryParse(string value, out PersonID entityID)
        {
            if (IntIdentifier.TryParse(value, out var id))
            {
                entityID = (PersonID)id;
                return true;
            }
            else
            {
                entityID = new PersonID();
                return false;
            }
        }
    }
```
## ID's Become Immutable Value Objects
One consequence of using an object instead of a primitive type like `int` is that the object needs to be instantiated when the entity is retrieved from persistent storage.

During any refactor which reduces technical debt, [repositories](https://docs.microsoft.com/en-us/aspnet/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application) are often introduced if they are not already in use.

When the repository retrieves an entity from persistent storage, it might use further abstraction via patterns, such as [adapter](https://en.wikipedia.org/wiki/Adapter_pattern) or [mediator](https://en.wikipedia.org/wiki/Mediator_pattern).

Implementing the adapter pattern:
``` C#
    public class PersonEntity
    {
        public int ID { get; set; }

        public string GivenName { get; set; }
        public string Surname { get; set; }
    }

    public class Person
    {
        public IIdentifier ID { get; set; }

        public string GivenName { get; set; }
        public string Surname { get; set; }

        public static Person Adapt(PersonEntity person)
        {
            return new Person
            {
                GivenName = person.GivenName,
                Surname = person.Surname,
                ID = new PersonID(person.ID)
            };
        }
    }
```
Using the adapter pattern, the repository might have code that looks something like this:
``` C#
public Person GetPersonByID(PersonID personID)
{
    var idRequiredByPersistentStorage = personID.ID;
    PersonEntity personFromStorage = ...;
    return Person.Adapt(personFromStorage);
}
```
## Changing the Underlying Type
When the need to change the underlying type of the `Person.ID` property to a type other than `int` arises, the `PersonEntity.ID` type would change (e.g., from `int` to `Guid`), and three names in the `PersonID` class need to be changed (in this example, from `IntIdentifier` to `GuidIdentifier`.)
``` C#
    public class PersonEntity
    {
        public Guid ID { get; set; }

        public string GivenName { get; set; }
        public string Surname { get; set; }
    }

    /// <summary>
    /// A Class which represents a <see cref="Person"/> entity's ID as a <see cref="Guid"/>.
    /// </summary>
    class PersonID : GuidIdentifier
    {
        public PersonID() : base()
        { /* No additional construction required. */ }

        public PersonID(Guid id) : base(id)
        { /* No additional construction required. */ }

        public PersonID(GuidIdentifier id) : base(id.ID)
        { /* No additional construction required. */ }

        public PersonID(string value, bool strict = true) : base(Parse(value).ID)
        { /* No additional construction required. */ }


        public static bool TryParse(string value, out PersonID entityID)
        {
            if (GuidIdentifier.TryParse(value, out var id))
            {
                entityID = (PersonID)id;
                return true;
            }
            else
            {
                entityID = new PersonID();
                return false;
            }
        }
    }    
```
No other code should need to be changed to make the change in type.
## Any Sub-type
The project includes support for `int`, `ulong`, `Guid` and `string` sub-types, but it is easy to add support for *any* sub-type, as long as that sub-type implements the [`IEquatable<T>`](https://docs.microsoft.com/en-us/dotnet/api/system.iequatable-1?view=net-5.0) and [`IComparable<T>`](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable-1?view=net-5.0) interfaces -- these interfaces allow two `EntityIdentifier` objects to be compared to one another for equality, and allows entities to be sorted by their IDs -- which is often desired as the default sort order for displaying the results of a query.

As an example, the `GuidIdentifier` class has fewer than 50 lines-of-code, and is almost entirely "boilerplate."
``` C#
   /// <summary>
    /// Used for describing an Entity ID having a <see cref="Guid"/> type.
    /// </summary>
    public class GuidIdentifier : IdentifierBase<Guid>
    {
        static Guid defaultValue = Guid.Empty;

        public GuidIdentifier() : base(defaultValue)
        { /* No additional construction required. */ }

        public GuidIdentifier(Guid id) : base(id)
        { /* No additional construction required. */ }


        public static IIdentifier<Guid> Parse(string value)
        {
            if (Guid.TryParse(value, out var guidID))
            {
                return new GuidIdentifier(guidID);
            }
            else
            {
                throw new ArgumentException("The given ID could not be parsed into a GUID value.",
                    nameof(value));
            }
        }


        public static bool TryParse(string value, out IIdentifier<Guid> id)
        {
            if (Guid.TryParse(value, out var guidID))
            {
                id = new GuidIdentifier(guidID);
                return true;
            }
            else
            {
                id = new GuidIdentifier(defaultValue);
                return false;
            }
        }


        /// <summary>
        /// Indicates whether or not the Entity ID contains a valid ID.
        /// </summary>
        public override bool IDIsAssigned => !ID.Equals(defaultValue);
    }
```
